/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "topic_server.h"
#include "sqlite3.h"
#include <stdio.h>

bool_t
init_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	int callback(void *NotUsed, int argc, char **argv, char **azColName) {
	   int i;
	   for(i = 0; i<argc; i++) {
	      printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
	   }
	   printf("\n");
	   return 0;
	}

	sqlite3 *database;
	char *error_msg = 0;
	int rc;
	char *sql;

	rc = sqlite3_open("topic_database.db", &database);

	if (rc) {
		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(database));
		retval = 0;
		*result = -1;
	} else {
		//fprintf(stderr, "Opened database successfully\n");
		retval = 1;
		*result = 0;
	}

	sql = "CREATE TABLE IF NOT EXISTS topic_texts("    \
		"name CHAR(256) PRIMARY KEY NOT NULL,"    \
		"text CHAR(256) NOT NULL);";

	rc = sqlite3_exec(database, sql, callback, 0, &error_msg);

   if( rc != SQLITE_OK ){
      fprintf(stderr, "SQL error: %s\n", error_msg);
      sqlite3_free(error_msg);
      retval = 0;
      *result = -1;
   } else {
      //fprintf(stdout, "Table created successfully\n");
      retval = 1;
      *result = 0;
   }
   
   	sqlite3_close(database);

	return retval;
}

bool_t
store_topic_text_1_svc(char *topic_name, char *topic_text, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */
	int callback(void *NotUsed, int argc, char **argv, char **azColName) {
	   int i;
	   for(i = 0; i<argc; i++) {
	      printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
	   }
	   printf("\n");
	   return 0;
	}

	sqlite3 *database;
	char *error_msg = 0;
	int rc;
	char sql[1024];

	rc = sqlite3_open("topic_database.db", &database);

	if (rc) {
		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(database));
		retval = 0;
		*result = -1;
	} else {
		//fprintf(stderr, "Opened database successfully\n");
		retval = 1;
		*result = 0;
	}

	sprintf(sql, "INSERT OR REPLACE INTO topic_texts (name, text) VALUES ('%s', '%s');", topic_name, topic_text);
	rc = sqlite3_exec(database, sql, callback, 0, &error_msg);

  	if( rc != SQLITE_OK ){
		fprintf(stderr, "SQL error: %s\n", error_msg);
		sqlite3_free(error_msg);
		retval = 0;
        *result = -1;
    } else {
    	//fprintf(stdout, "Insert successfully done\n");
    	retval = 1;
        *result = 0;
    }
   
   	sqlite3_close(database);

	return retval;
}

bool_t
retrieve_topic_text_1_svc(char *topic_name, char **result,  struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */
	int callback(void *NotUsed, int argc, char **argv, char **azColName) {
	   int i;
	   char aux[1024];
	   for(i = 0; i<argc; i++) {
	       //printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
	       sprintf(aux, "%s\n", argv[i] ? argv[i] : "NULL");
	   	   strcat(*result, aux);
	   }   
	   printf("\n");
	   return 0;
	}

	sqlite3 *database;
	char *error_msg = 0;
	int rc;
	char sql[1024];
	//const char* data = "Callback function called";
	*result = (char *) malloc(1024);
	strcpy(*result, "");

	rc = sqlite3_open("topic_database.db", &database);

	if (rc) {
		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(database));
		retval = -1;
		strcpy(*result, "");
	} else {
		//fprintf(stderr, "Opened database successfully\n");
		retval = 0;
	}

	sprintf(sql, "SELECT text FROM topic_texts WHERE name='%s';", topic_name);
	rc = sqlite3_exec(database, sql, callback, 0, &error_msg);

	if( rc != SQLITE_OK ){
		fprintf(stderr, "SQL error: %s\n", error_msg);
		sqlite3_free(error_msg);
		strcpy(*result, "");
		retval = 0;
    } else {
    	//fprintf(stdout, "Operation done successfully\n");
    	retval = 1;
    }
   
   	sqlite3_close(database);

	return retval;
}

int
topic_server_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
